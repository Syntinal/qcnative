{
  "author": {
    "name": "Joshua Barney",
    "email": "joshmbarney@icloud.com"
  },
  "homepage": "http://TODO",
  "name": "qcnode",
  "description": "The QuickConnect Framework for Node.js",
  "version": "1.3.5",
  "private": false,
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "node tests/test.js"
  },
  "main": "./QuickConnect.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/JoshRagem/QCNode.git"
  },
  "keywords": [
    "stack",
    "quickconnect",
    "rapid",
    "async",
    "asynchronous",
    "functional"
  ],
  "engines": {
    "node": ">=0.8"
  },
  "readme": "QCNode 1.3.5\n======\n\nThe QuickConnect Framework for Node.js. Flow control, application controller logic, and so much more!\n\n## Installation\n```\nnpm install qcnode\n```\n\n## What is it for?\n\nThe QuickConnect framework for Node.js is designed to help the developer quickly write, debug, and run asynchronous or synchronous code. The framework encourages code re-use and modularity.\n\n## How do I use it?\n\nThere are many ways!\n\n### Simple Example\n```\nQuickConnect = require('qcnode').QuickConnect\nvar qc = new QuickConnect\n\nqc.command('list filtered files', function(){\n\tthis.valcf( function(data, qc){\n\t\tif(qc === this){ //it does\n\t\t\treturn this.STACK_CONTINUE\n\t\t} else {\n\t\t\treturn \"this is impossible\"\n\t\t}\t\t\n\t})\n\tthis.dcf( function(data, qc){\n\t\tfs.readdir(data.dirPath, function(err, files){\n\t\t\tif(err){\n\t\t\t\t//maybe handle it here, if I want\n\t\t\t\tqc.asyncStackError(err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tqc.asyncStackContinue('files',files)\n\t\t})\n\t\treturn qc.WAIT_FOR_DATA\n\t})\n\tthis.dcf( function(data, qc){\n\t\tdata.filteredFiles = data.files.filter(function(val){return val != data.filter})\n\t})\n\tthis.vcf( function(data, qc){\n\t\tfor(var fi in data.filteredFiles){\n\t\t\tconsole.log(fi)\n\t\t}\n\t\treturn qc.STACK_EXIT\n\t})\n})\n\n...\n\nvar stack = qc.handleRequest('login', myData) // .handleRequest === .run\n\nstack.on('error', function(err, data, index){\n\t//handle the error out here, where I know what is going on.\n\tconsole.log(\"unable to filter files right now: \"+err.stack)\n})\n\nstack.on('end', function(data, index){\n\tconsole.log('yay!')\n})\n\n```\n\n### Less Simple Example\n```\nqc.isolate('request' function(){\n\tthis.isolate( 'GET', function(){\n\t\tthis.command('contest', function(){\n\t\t\tthis.valcf(function(data){\n\t\t\t\tif(+new Date < limit){\n\t\t\t\t\treturn \"the contest has not begun\"\n\t\t\t\t}\n\t\t\t\treturn this.STACK_CONTINUE\n\t\t\t})\n\t\t\tthis.dcf(function(data){\n\t\t\t\tdata.response.writeHead(200)\n\t\t\t\tdata.response.end(JSON.stringify({message:\"you are a winner!\"}))\n\t\t\t\treturn this.STACK_CONTINUE\n\t\t\t})\n\t\t})\t\n\t})\n\tthis.isolate( 'DELETE', function(){\n\t\t//more logic\n\t})\n})\n\n...\n\nhttp.createServer(function(req, res){\n\t//this will dynamically select what command to run based on the url!\n\t\n\turl = require('url').parse(req.url, true)\n\taction = ['request',req.method]\n\turlParts = url.pathname.split('/').filter(function(v){return v})//removes ''\n\taction = action.concat(urlParts)\n\ttry {\n\t\tqc.run(action,{response:res},{ \n\t\t\terror: function(err){\n\t\t\t\tres.write(500)\n\t\t\t\tres.end(\"error\")\n\t\t\t},\n\t\t\tvalidateFail: function(failMsgs){\n\t\t\t\tres.write(422)\n\t\t\t\tres.end(JSON.stringify({errors:failsMsgs}))\n\t\t\t}\n\t\t})\n\tcatch (err) {\n\t\t//stack is not defined\n\t\tres.write(404)\n\t\tres.end(cached404page)\n\t}\n})\n```\n#### Josh, you just made more callbacks…\nUm… No I didn't! Pay no attention to the man behind the callbacks! This code gets run top-to-bottom; the callbacks are just helpers.\n\nWell, fine. These examples are actually written in a shorthand that was helpful while writting coffeescript. it looks like this in coffeescript:\n\n```\nqc.isolate 'request', ->\n\t@isolate 'GET', ->\n\t\t@command 'contest', ->\n\t\t\t@valcf (data) ->\n\t\t\t\tif +new Date < limit\n\t\t\t\t\t\"the contest has not begun\" \n\t\t\t\telse \n\t\t\t\t\t@STACK_CONTINUE\n\t\t\t@dcf (data) ->\n\t\t\t\tdata.response.writeHead 200\n\t\t\t\tdata.response.end JSON.stringify message:\"you are a winner!\"\n\t@isolate 'DELETE', ->\n\t\t#more logic\n```\n\nIt's pretty simple to write and read with that shorthand. Here is what is actually happening _in the code:_\n\n```\nvar delim = qc.mapper.isolateDelimiter\nqc.mapper.mapCommandToValCF(['request','GET','contest'].join(delim), myValCF)\nqc.mapper.mapCommandToValCF(['request','GET','contest'].join(delim), myDCF)\nect...\n```\n\nThat is also very readable, but it takes a lot of characters.\n\n### Do you like Chaining?\nSince `isolate`,`command`, and the `cf` functions all return the same object that is `this` in the callbacks, you can chain! Here is an example from the qc tests:\n\n```\nbasic.command('basic stack to call')\n    .valcf(function(data, qc){\n        if (data.helol) {\n            return qc.STACK_CONTINUE\n        } else {\n            return \"this should not have been returned\"\n        }\n    })\n    .dcf(function(data, qc){\n        assert(data.helol)\n        return this.STACK_CONTINUE\n    })\n    .dcf(function(data, qc){\n        setTimeout(function () {\n            qc.asyncStackContinue()\n        }, 5)\n        return this.WAIT_FOR_DATA\n    })\n    .dcf(function(data, qc){\n        setTimeout(function () {\n            qc.asyncStackContinue('key','koy')\n        }, 50)\n        return this.WAIT_FOR_DATA\n    })\n    .dcf(function(data, qc){\n        assert.equal(data.key,'koy')\n        return this.STACK_CONTINUE\n    })\n    .vcf(function(data, qc){\n        data.done = true\n        return this.STACK_CONTINUE\n    })\n```\nThat's probably a more javascript-y way.\nYou just have to remember that `isolate`, `command`, and `cf` functions do not return the same object. This is not valid:\n\n```\n//error!\nbasic.isolate(isol).command(mycom).valcf(myfunc).command(otherCom).ect(…)\n```\nRemember, if you can chain something, you can store it.\n\n```\niso = basic.isolate(isol)\ncomOne = iso.command(mycom)\ncomOne.valcf(myfunc).dcf(dfunc)\ncomTwo = iso.command(otherCom)\ncomTwo.ect(...)\n```\n\n## So?\n\nSo this is awesome! You can use QC in the way that works for you. It's more than just flow control, it's designed to help you get things done faster, higher, and stronger. \n\n## But how can I use it in ...?\nHead on over to [our example page!](https://github.com/JoshRagem/QCNode/wiki/examples)\n\n## QC History\nQuickConnect started as a response to some of the problems encountered writing code for Enterprise Java servers. The framework pattern evolved for several years in a hybrid mobile environment (QCHybrid, iOS and Android) which provided tools for rapid prototyping of cross-platform apps. \n\nFrom the async javascript environment of mobile web views, the jump to Node.js was natural, but required some heavy thinking and adaptation to match the node way of doing things. The first port was done by a developer for a mobile app company--this port was made open source after donation back to the main QC developer. The first version published for install via npm was a complete re-write of that first port; this resulted in a smaller, better QC that fuctions across many versions of node.\n\n### Version numbers\nQC is pretty mature and very functional, so it didn't make sense to publish a version <1.0.0\n\nHere is how it works: When we change to version x.y.z\n\n* x : your stuff will probably break\n* y : your stuff will probably not break\n* z : we fixed something, wrote a test, or something small\n\n## Contribute\nBecause QC has a history older than Node.js, it has some things in it that are leftovers from other incarnations. 'handleRequest' is the oldest part; it comes from living on a server that handles client requests. It has been pointed out that a 'request', a 'command', and a 'stack' are all related, but come from different points in the history. We want to increase the 'y' part of the version by building better ways for people to use QC in their codeflow and workflow.\n\nFork the repo, submit a pull request and tell us your rational for the change; we would love to hear all ideas.\n\nWe feel the core logic of QC is pretty set in version 1.0.0, but if you have ideas for version 2.0.0, fork the repo or drop us a line!\n\n# Licence\nMIT\nCopyright (c) 2013 Joshua Barney, Lee Barney\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/JoshRagem/QCNode/issues"
  },
  "_id": "qcnode@1.3.5",
  "dist": {
    "shasum": "0b6a7cdb6ed5c27afcd50ca597acd3962c8d2e1a"
  },
  "_from": "qcnode@1.3.5",
  "_resolved": "https://registry.npmjs.org/qcnode/-/qcnode-1.3.5.tgz"
}
